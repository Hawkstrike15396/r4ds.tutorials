---
title: A field guide to base R
author: David Kane and Aryan Kancherla
tutorial:
  id: a-field-guide-to-base-R
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 28: A field guide to base R'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 


x <- c("one", "two", "three", "four", "five")

x2 <- c(10, 3, NA, 5, 8, 1, NA)

x3 <- c(abc = 1, def = 2, xyz = 5)

df <- tibble(
  x = 1:3, 
  y = c("a", "e", "f"), 
  z = runif(3)
)

df0 <- tibble(
  x = c(2, 3, 1, 1, NA), 
  y = letters[1:5], 
  z = runif(5)
) 

tb <- tibble(
  x = 1:4,
  y = c(10, 4, 1, 21)
)


```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 28: A field guide to base R](https://r4ds.hadley.nz/base-r) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 

In this chapter, we’ll focus on four big topics: subsetting with [, subsetting with [[ and $, the apply family of functions, and for loops. To finish off, we’ll briefly discuss two essential plotting functions. These topics are particularly useful as you do more programming and will help you read code you’ll encounter in the wild.

## Subsetting with a single bracket
### 

The `[` bracket can be used to extract sub-components from data frames and vectors, with the syntax `x[i]`. `x` represents the vector and `i` represents the position of the value inside of `x` (1st element is position 1, second element is position 2, and so forth). 

### Exercise 1

Load the tidyverse library

```{r subsetting-with-a-si-1, exercise = TRUE}

```

### 

There are five main types of things that you can subset a vector with, which will be covered in the following exercises:

1) A vector of positive integers
2) A vector of negative integers
3) A logical vector
4) A character vector
5) Nothing

### Exercise 2

Press "Run Code".

```{r subsetting-with-a-si-2, exercise = TRUE}
x <- c("one", "two", "three", "four", "five")
```

### 

This code sets the variable `x` to the vector `c("one", "two", "three", "four", "five")`. 

### Exercise 3

Extract the first element of `x` by typing `x[]` with the number `1` inside the brackets

```{r subsetting-with-a-si-3, exercise = TRUE}

```

```{r subsetting-with-a-si-3-hint-1, eval = FALSE}
x[...]
```

### 

As you can see, the code extracts the first value of the `x` vector, printing out the value "one". 

### Exercise 4

We can also pass in a vector to `[]`, containing various positions to extract from `x`. In the code chunk below, extract the 2nd, 3rd, and 4th values of `x`, using `c()`

```{r subsetting-with-a-si-4, exercise = TRUE}

```

```{r subsetting-with-a-si-4-hint-1, eval = FALSE}
x[c(..., ..., ...)]
```

### 

When you run the code above, you should see that it extracts "two", "three", and "four". By using vectors inside `[]`, you can extract multiple elements at once.

### Exercise 5

You can also pass in a vector of negative values. In the code chunk below, type `x[]`, placing the vector `c(-1, -2)` inside the brackets. Oberseve what happens.

```{r subsetting-with-a-si-5, exercise = TRUE}

```

```{r subsetting-with-a-si-5-hint-1, eval = FALSE}
x[c(..., ...)]
```

### 

Negative values drop the elements at the specified positions; the code above drops the first and second elements, returning "three", "four", and "five".

### Exercise 6

Subsetting with logical vectors are another type of thing that you can subset a vector with. Create a vector with the values `10`, `3`, `NA`, `5`, `8`, `1`, and `NA`. Save this to a variable named `x2`.

```{r subsetting-with-a-si-6, exercise = TRUE}

```

```{r subsetting-with-a-si-6-hint-1, eval = FALSE}
... <- c(10, 3, NA, 5, 8, 1, NA)
```

### 

Subsetting with a logical vector keeps all values corresponding to a TRUE value. This is most often useful in conjunction with the comparison functions.

### Exercise 7

`is.na()` is a function that identifies missing values in vectors, data frames, etc. In the code chunk below, type `x2[]`, placing `is.na(x2)` inside of the brackets.


```{r subsetting-with-a-si-7, exercise = TRUE}

```

```{r subsetting-with-a-si-7-hint-1, eval = FALSE}
x2[is.na(x2)]
```

### 

This code prints out the missing values (the `NA`'s) stored inside `x2`. Unlike `filter()`, NA indicies will be included in the output as `NA`'s.

### Exercise 8

Let's extract all the even values of `x2`. In the code chunk below, type `x2[]` and extract the even numbers using the `%%` operator.


```{r subsetting-with-a-si-8, exercise = TRUE}

```

```{r subsetting-with-a-si-8-hint-1, eval = FALSE}
x2[x2 %% 2 == 0]
```

### 

The `%%` operator is used to calculate the remainder of the division of 2 numbers. So, by placing `x2 %% 2 == 0` inside the brackets, the code will search through each element of `x2` and return all of the numbers with a remainder of 0 when divided by 2 (thus being an even number). And as mentioned previously, all `NA` indicies will be included in the output as `NA`

### Exercise 9

The last kind of vector that you can subset is a character vector. Using the following vector below, lets extract the `xyz` element. On a new line, type `x3` followed with a pair of brackets, passing in the string `"xyz"`

```{r subsetting-with-a-si-9, exercise = TRUE}
x3 <- c(abc = 1, def = 2, xyz = 5)
```

```{r subsetting-with-a-si-9-hint-1, eval = FALSE}
x3["..."]
```

### 

Along with sub-setting logical, character, and integer vectors, you can also subset nothing. For example, by running `x[]` on the code above, it'll just return the vector `x`.


### Exercise 10

Sub-setting can not only be used on vectors; it works on data sets too. In the code chunk below, create a tibble called `df`. The first argument, `x`, should contain a range of numbers from 1 to 3. The second argument, `y`, should be set to the vector `c("a", "e", "f")`. The third argument, `z`, should be set to `runif(3)`. After completing this, run `df` on a new line.


```{r subsetting-with-a-si-10, exercise = TRUE}

```

```{r subsetting-with-a-si-10-hint-1, eval = FALSE}
... <- tibble(x = ... : ...,
              y = c("...", "...", "..."),
              z = runif(...)
              )
```

### 

There are many ways to use `[` with data sets, but the most common way is to subset by selecting rows and columns, with the syntax `df[row, col]`.


### Exercise 11

Using `df`,  let's extract the letter "a". On a new line, type `df` followed by a pair of brackets. In the brackets, type `1,2`. 

```{r subsetting-with-a-si-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r subsetting-with-a-si-11-hint-1, eval = FALSE}
df[... , ...]
```

### 

This extracts the element in the 1st row, 2nd column, which is the letter "a". 

### Exercise 12

You can also leave the row/column input blank when extracting data from a data set. For example, `df[rows, ]` returns the specified row(s) and all columns in the data set, while `df[, cols]` returns all rows and the specified column(s) in the data set. 

In the code chunk below, extract all the rows in `df`, as well as the columns `x` and `z`.

```{r subsetting-with-a-si-12, exercise = TRUE}

```

```{r subsetting-with-a-si-12-hint-1, eval = FALSE}
df[, c("...", "...")]
```

### 

As you can see, by leaving the first part of the subset blank (the part before the comma), the code returns all of the rows in `df`, but only returns columns `x` and `z` due to the vector inputted after the comma.

### Exercise 13

There’s an important difference between tibbles and data frames when it comes to `[` . In the tutorials, we’ve mainly used tibbles, which are data frames, but they tweak some behaviors to make your life a little easier. In most places, you can use “tibble” and “data frame” interchangeably, so when we want to draw particular attention to R’s built-in data frame, we’ll write data.frame. 

Press "Run Code".


```{r subsetting-with-a-si-13, exercise = TRUE}
df1 <- data.frame(x = 1:3)
df2 <- tibble(x = 1:3)

df1
df2
```

### 

If `df` is a data.frame, then `df[, cols]` will return a vector if `col` selects a single column and a data frame if it selects more than one column. If `df` is a tibble, then `[` will always return a `tibble.

### Exercise 14

Press "Run code".

```{r subsetting-with-a-si-14, exercise = TRUE}
df0 <- tibble(
  x = c(2, 3, 1, 1, NA), 
  y = letters[1:5], 
  z = runif(5)
)

df0
```

### 

### Exercise 15

The `dplyr` package contains many equivalents of subsetting, such as `filter()`, `arrange()`, `select()`, and `relocate()` functions.


Let's observe the `filter()` equivalent. Pipe `df0` (with the `|>`) to the filter function. Pass `x > 1` into `filter()`.


```{r subsetting-with-a-si-15, exercise = TRUE}

```

```{r subsetting-with-a-si-15-hint-1, eval = FALSE}
... |> 
  ...(x > ...)
```

### 

`filter()` is equivalent to subsetting the rows with a logical vector, taking care to exclude any missing values. For this scenario, the equivalent subset code would be `df0[!is.na(df0$x) & df0$x > 1, ]`. Running this code produces the same result.

### 

The `$` symbol is used to pull out columns from data frames. We will go over the `$` symbol in the next section.

### Exercise 16

`arrange()` is equivalent to subsetting the rows with an integer vector, usually created with order(). In the code chunk below, pipe `df0` to `arrange()`, passing in `x, y`. Then, on a new line, paste its equivalent: `df0[order(df0$x, df0$y),]`


```{r subsetting-with-a-si-16, exercise = TRUE}

```

```{r subsetting-with-a-si-16-hint-1, eval = FALSE}
... |> 
  ...(x, y)

df0[order(df0$x, df0$y), ]
```

### 

You can use `order(decreasing = TRUE)` to sort all columns in descending order or `-rank(col)` to sort columns in decreasing order individually.

### Exercise 17

`select()` is equivalent to subsetting columns with character vector. In the code chunk below, pipe `df0` to `select()`, passing in `x, z` to `select()`. Then, on a new line, paste its equivalent: `df0[, c("x", "z")]`


```{r subsetting-with-a-si-17, exercise = TRUE}

```

```{r subsetting-with-a-si-17-hint-1, eval = FALSE}
... |>
  ...(x, z)

df0[, c("x", "z")]
```

### 

`filter()`, `arrange()`, and `select()` are very useful functions that help organize data. You will use these functions quite often when analyzing data. 

### 

## Subsetting with double brackets and a dollar sign
###

`[`, which selects many elements, is paired with `[[` and `$`, which extract a single element. In this section, we’ll show you how to use `[[` and `$` to pull columns out of data frames, discuss a couple more differences between data.frames and tibbles, and emphasize some important differences between `[` and `[[` when used with lists.

###

### Exercise 1

In the code chunk below, create a tibble. The first value should be `x`, which is equal to a range of integers from 1 to 4. The second value should be `y`, which is a vector containing 10, 4, 1, and 21. Save this tibble to the name `tb` and print it on a new line.

```{r subsetting-with-doub-1, exercise = TRUE}

```

```{r subsetting-with-doub-1-hint-1, eval = FALSE}
... <- tibble(x = .. : .., y = c(..., ..., ..., ...))
```


### 

### Exercise 2

`[[` and `$` can be used to extract columns out of a data frame. `[[` can access by position or by name, and `$` is specialized for access by name.

In the code chunk below, lets extract the elements of column `x`. In the code chunk below, type in `tb` followed by `[[]]`. Inside the inner bracket, type in `1`.



```{r subsetting-with-doub-2, exercise = TRUE}

```

```{r subsetting-with-doub-2-hint-1, eval = FALSE}
tb[[...]]
```

### 

In this scenario, the `[[]]` are being used to return the values by position. By placing the number `1` inside the brackets, the code returns the values in the first position, which are the range of integers stored in column `x`. 


### Exercise 3

Now, lets extract the same elements by name. Copy the code above, replacing the code inside the inner bracket with `"x"`


```{r subsetting-with-doub-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

### 


## Apply family
## For loops
## Plots
## Summary
### 

This tutorial covered [Chapter 28: A field guide to base R](https://r4ds.hadley.nz/base-r) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
`


```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
