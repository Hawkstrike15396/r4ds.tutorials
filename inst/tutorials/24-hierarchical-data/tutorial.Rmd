---
title: Hierarchical data
author: David Kane
tutorial:
  id: hierarchical-data
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 24: Hierarchical data'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(tidyverse)
library(repurrrsive)
library(jsonlite)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
x1 <- list(1:4, "a", TRUE)
x2 <- list(a = 1:2, b = 1:3, c = 1:4)
x5 <- list(1, list(2, list(3, list(4, list(5)))))
df <- tibble(
  x = 1:2, 
  y = c("a", "b"),
  z = list(list(1, 2), list(3, 4, 5))
)
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 24: Hierarchical data](https://r4ds.hadley.nz/rectangling.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to work with non-rectanglar data using packages like [**jsonlite**](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html). 


## Lists
###

So far you’ve worked with data frames that contain simple vectors like integers, numbers, characters, date-times, and factors. These vectors are simple because they’re homogeneous: every element is of the same data type.If you want to store elements of different types in the same vector, you’ll need a list, which you create with `list()`.

### Exercise 1

To create our first list, let's create a variable x1 and assign the list() function to it. We will pass in three different data types within list(): the range of integers 1:4 to generate four integers, the string "a", and the Boolean value TRUE. On a new line, we'll call the variable x1. 

```{r lists-1, exercise = TRUE}

```


```{r lists-1-hint, eval = FALSE}
x1 <- list(...,"a",...)
x1
```

###

When you run x1, you will get all the data types that were passed in, along with their corresponding indices. If you want to access a specific data type by its index, such as finding the element in the first index of x1, you can use the square brackets notation: x1[1]. This will return the integers. 

### Exercise 2

It's indeed convenient to name the components, or children, of a list. To accomplish this, let's create a new variable `x2` and assign the `list()` function to it. Within `list()`, we'll define three columns named `a`, `b`, and `c`. We'll assign `1:2` to `a`, `1:3` to `b`, and `1:4` to `c`. On a new line call `x2`.

```{r lists-2, exercise = TRUE}

```


```{r lists-2-hint, eval = FALSE}
... <- list(a = ..., b = ...,... = 1:4)
x2
```

###

When you run `x2`, you will see that each column contains different values. To access individual columns of the list, you can use the `$` operator since we have named the columns. For example, to access the column a from `x2`, you can use `x2$a`. 

### Exercise 3

Even for these very simple lists, printing takes up quite a lot of space. A useful alternative is `str()`, which generates a compact display of the structure, de-emphasizing the contents.

Run `str()` and pass in `x1` and on a new line run `str()` again and pass in `x2`.

```{r lists-3, exercise = TRUE}

```


```{r lists-3-hint, eval = FALSE}
str(...)
str(...)
```

###

As you can see, str() displays each child of the list on its own line. It displays the name, if present, then an abbreviation of the type, then the first few values.

### Exercise 4

Lists can contain any type of object, including other lists. This makes them suitable for representing hierarchical (tree-like) structures.

To create a representation of hierarchical structures, let's create a variable `x3` and assign `list()` to it. Within `list()`, we will pass in `list(1,2)` and `list(3,4)`. This means we will have two lists nested inside a single list. Then on a new line run `str()` and pass in `x3`.

```{r lists-4, exercise = TRUE}

```


```{r lists-4-hint, eval = FALSE}
... <- list(list(...), ...(3, 4))
str(...)
```

###

This is notably different to `c()`, which generates a flat vector like when we run `c(c(1, 2), c(3, 4))`, we get `#> [1] 1 2 3 4` which is flat.

### Exercise 5

Now what if we pass in two list in a vector, will we get a heirichal vector or a flat vector?

To find out, create a new variable `x4` and assign it to vector function `c()`. Within `c()` pass in `list(1,2)` and pass in `list(3,4)`. On a new line, run `str()` and pass in `x4`.

```{r lists-5, exercise = TRUE}

```


```{r lists-5-hint, eval = FALSE}
... <- c(list(...), ...(3, ...))
str(...)
```

###

Even when we pass in lists, we get no hierarchical data and just get the numbers in row like order.

### Exercise 6

As lists get more complex, `str()` gets more useful, as it lets you see the hierarchy at a glance.

Run `x5` which is very complex list.

```{r lists-6, exercise = TRUE}

```


```{r lists-6-hint, eval = FALSE}
x5
```

###

when we ran `x5` we get some many duplicate numbers in brackets and it's all confusing and complex. This is where `str()` comes to shine.

### Exercise 7

Now run `str(x5)`.

```{r lists-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r lists-7-hint, eval = FALSE}
str(x5)
```

###

Now this dosen't mean in you should always use `str()` to visualize because as lists get even larger and more complex, `str()` eventually starts to fail, and you’ll need to switch to `View()`.

### Exercise 8

The image below show the result of calling `view(x5)`.

```{r}
knitr::include_graphics("images/View-1.png")
```

###

The RStudio view lets you interactively explore a complex list. The viewer opens showing only the top level of the list.

### Exercise 9

Clicking on the rightward facing triangle expands that component of the list so that you can also see its children like the image below.

```{r}
knitr::include_graphics("images/View-2.png")
```

###

You can repeat this operation as many times as needed to get to the data you’re interested in. Note the bottom-left corner: if you click an element of the list, RStudio will give you the sub-setting code needed to access it, in this case `x5[[2]][[2]][[2]]`

### Exercise 9

Like said previously, the image below is what it looks like if we repeat the operation.

```{r}
knitr::include_graphics("images/View-3.png")
```

###

Now that's we have knowledge of Hierarchy data, let's move on to List-columns.

### Exercise 10

Lists can also live inside a tibble, where we call them list-columns. List-columns are useful because they allow you to place objects in a tibble that wouldn’t usually belong in there.

To demonstrate a simple example of list-column, create a variable `df` and assign `tibble()` to it. Within `df` we will have three columns: `x`, `y`, `z`. Pass in `1:2` for `x`, `c("a","b")` for `y`, and `list(list(1,2),list(3,4,5))` for `z`. On a new line run `df`.

```{r lists-10, exercise = TRUE}

```


```{r lists-10-hint, eval = FALSE}
... <- tibble(
  ... = 1:2, 
  y = c("a", "b"),
 ... = list(list(1,...), ...(3, ..., 5))
)
df
```

###

In particular, list-columns are used a lot in the tidymodels ecosystem, because they allow you to store things like model outputs or resamples in a data frame.

### Exercise 11

There’s nothing special about lists in a tibble; they behave like any other column. To show this, start a pipe with `df`  to `filter()` and we want all values where `x == 1` only.

```{r lists-11, exercise = TRUE}

```



```{r lists-11-hint, eval = FALSE}
df |> 
  filter(x == 1)
```

###

Computing with list-columns is harder, but that’s because computing with lists is harder in general.

Good Work on finishing this section, next up , we'll be focusing on unnesting list-columns into regular variables.


## Unnesting
###

## Case Studies
###

## JSON
###


## Summary
### 

This tutorial covered [Chapter 24: Hierarchical data](https://r4ds.hadley.nz/rectangling.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You learned how to work with non-rectanglar data using packages like [**jsonlite**](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html).

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
