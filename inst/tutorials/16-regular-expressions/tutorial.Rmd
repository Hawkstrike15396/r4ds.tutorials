---
title: Regular expressions
author: David Kane
tutorial:
  id: regular-expressions
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 15: Strings'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Knowledge drop the two links from the summary. -->

<!-- Maybe one of the nice looking babynames lots could go at the end of this tutorial. Or maybe we make a new one? -->


## Introduction
### 

This tutorial covers [Chapter 16: Regular expressions](https://r4ds.hadley.nz/regexps.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. With the help of the [**stringr**](https://stringr.tidyverse.org/index.html) package, we use regular expressions, a concise and powerful language for describing patterns within strings. 


## Pattern basics
### 

The term "regular expression" is a bit of a mouthful, so most people abbreviate it to "regex" or "regexp."


### Exercise 1

Run `library(tidyverse)` in the Console. Copy/paste the resulting message.

```{r pattern-basics-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

There are currently nine core packages in the *Tidyverse*, although that number may grow over time. **stringr** is the main package with which we use regular expressions.


### Exercise 2

Load the **babynames** package with `library()` below. Don't forget to hit "Run Code."


```{r pattern-basics-2, exercise = TRUE}

```

```{r pattern-basics-2-hint-1, eval = FALSE}
library(...)
```

There is no return value.


### Exercise 3

In the Console, run `library(babynames)` and then look up the help page for the `babynames` tibble by running `?babynames`. Copy/paste the Format information below.

```{r pattern-basics-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The definition of the `prop` variable is subtle.




### Exercise 4

Run `glimpse()` on the `babynames` tibble.

```{r pattern-basics-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-4-hint-1, eval = FALSE}
glimpse(...)
```

### 

There are almost 2 millions rows! 

### Exercise 5

Run `fruit` at the Console. CP/CR.

```{r pattern-basics-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 15)
```

### 

In addition to `babynames`, we will use three character vectors from the **stringr** package:

* `fruit` contains the names of 80 fruits.
* `words` contains 980 common English words.
* `sentences` contains 720 short sentences.


### Exercise 6

Type `str_view(fruit, "berry")`. Hit "Run Code." (Unless we specifically indicate that you should use the Console, you should enter commands into the exercise code block and press "Run Code.") 

The first argument to `str_view()` is the vector which you are searching through. The second argument is the regular expression which you are searching for.


```{r pattern-basics-6, exercise = TRUE}

```

```{r pattern-basics-6-hint-1, eval = FALSE}
str_view(fruit, "berry")
```

### 

`str_view()` will show only the elements of the string vector that match, surrounding each match with <>, and, where possible, highlighting the match in blue.


### Exercise 7

Letters and numbers match exactly and are called *literal characters*. Most punctuation characters, like `.`, `+`, `*`, `[`, `]`, and `?`, have special meanings2 and are called *metacharacters*.

Run `str_view()` with `c("a", "ab", "ae", "bd", "ea", "eab")` as the first argument --- this is the vector which we are searching through --- and `"a."` as the second argument.

A `.` will match any character, so `"a."` will match any string that contains an “a” followed by another character. 


```{r pattern-basics-7, exercise = TRUE}

```

```{r pattern-basics-7-hint-1, eval = FALSE}
str_view(c("a", "ab", "ae", "bd", "ea", "eab"), ...)
```

### 

There are three matches. Notice how the `<>` pull out the actual match itself, leaving irrelevant letters, like the "e" in the last match, outside.

### Exercise 8

Run `str_view()` on `fruit` as the vector and `"a...e"` as the pattern.

```{r pattern-basics-8, exercise = TRUE}

```

```{r pattern-basics-8-hint-1, eval = FALSE}
str_view(..., "a...e")
```

Try to interpret the pattern before we tell you the answer . . .

### 

The matches are any fruit which includes an "a", followed by any three characters, followed by an "e". Look at the matches to confirm that they all follow this rule.


### Exercise 9

*Quantifiers* control how many times a pattern can match:

* `?` makes a pattern optional (i.e. it matches 0 or 1 times)
* `+` lets a pattern repeat (i.e. it matches at least once)
* `*` lets a pattern be optional or repeat (i.e. it matches any number of times, including 0).

Run `str_view()` on `c("a", "ab", "abb")` as the vector and `"ab?"` as the pattern.


```{r pattern-basics-9, exercise = TRUE}

```

```{r pattern-basics-9-hint-1, eval = FALSE}
str_view(c("a", "ab", "abb"), ...)
```

### 

Note how "a" matches "ab?" because the "?" makes the "b" optional.

### Exercise 10

Run `str_view()` on `c("a", "ab", "abb")` as the vector and `"ab+"` as the pattern.

```{r pattern-basics-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-10-hint-1, eval = FALSE}
str_view(..., "ab+")
```

### 

`"ab+"` matches an "a", followed by at least one "b".

### Exercise 11

Run `str_view()` on `c("a", "ab", "abb")` as the vector and `"ab*"` as the pattern.

```{r pattern-basics-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-11-hint-1, eval = FALSE}
str_view(c("a", "ab", "abb"), ...)
```

### 

`ab*` matches an "a", followed by any number of "b"s, including zero "b"s.

### Exercise 12

*Character classes* are defined by `[]` and let you match a set of characters, e.g., `[abcd]` matches “a”, “b”, “c”, or “d”.

Run `str_view()` on `words` as the vector and `"[aeiou]x[aeiou]"` as the pattern.

```{r pattern-basics-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-12-hint-1, eval = FALSE}
str_view(..., "[aeiou]x[aeiou]")
```

Can you explain what is going on?

### 

We are matching all the words which feature the patter of any vowel, followed by an "x", followed by any vowel.

### Exercise 13

You can also invert the match by starting with ^: [^abcd] matches anything except “a”, “b”, “c”, or “d”. 

Run `str_view()` on `words` as the vector and `"[^aeiou]y[^aeiou]"` as the pattern.

```{r pattern-basics-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-13-hint-1, eval = FALSE}
str_view(words, "...")
```

### 

The `"[^aeiou]y[^aeiou]"` pattern finds every instance of any non-vowel, followed by "y", followed by any non-vowel.

### Exercise 14

You can use alternation, `|`, to pick between one or more alternative patterns.

Run `str_view()` on `fruit` as the vector and `"apple|melon|nut"` as the pattern.

```{r pattern-basics-14, exercise = TRUE}

```

```{r pattern-basics-14-hint-1, eval = FALSE}
str_view(..., "apple|melon|nut")
```

### 

The `"apple|melon|nut"` pattern matches any fruit which contains one of the three options. T

### Exercise 15

Run `str_view()` on `fruit` as the vector and `"aa|ee|ii|oo|uu"` as the pattern. his should find all the fruits with at least one repeated vowel.

```{r pattern-basics-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pattern-basics-15-hint-1, eval = FALSE}
str_view(fruit, ...)
```

### 

Regular expressions are very compact and use a lot of punctuation characters, so they can seem overwhelming and hard to read at first. Don’t worry; you’ll get better with practice, and simple patterns will soon become second nature. 


## Key functions
### 

Now that you’ve got the basics of regular expressions under your belt, let’s use them with some **stringr** and **tidyr** functions. In the following section, you’ll learn how to detect the presence or absence of a match, how to count the number of matches, how to replace a match with fixed text, and how to extract text using a pattern.

## Pattern details
### 

## Pattern control
### 

## Practice
### 

## Regular expressions in other places
### 

## Summary
### 

This tutorial covered [Chapter 16: Regular expressions](https://r4ds.hadley.nz/regexps.html)  from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. With the help of the [**stringr**](https://stringr.tidyverse.org/index.html) package, we used regular expressions, a concise and powerful language for describing patterns within strings. 

If you want to learn more, a good place to start is [`vignette("regular-expressions", package = "stringr")`](https://stringr.tidyverse.org/articles/regular-expressions.html): it documents the full set of syntax supported by the [**stringr**](https://stringr.tidyverse.org/index.html) package. Another useful reference is `https://www.regular-expressions.info/`. It’s not R specific, but you can use it to learn about the most advanced features of regexes and how they work under the hood.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
