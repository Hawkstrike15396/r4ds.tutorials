---
title: Numbers
author: Srihith Garlapati
tutorial:
  id: numbers
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 14: Numbers'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(primer.data)
library(readr)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

df <- tribble(
  ~x, ~y,
  1,  3,
  5,  2,
  7, NA,
)

x3 <- c(1, 2, 5, 10, 15, 20)
x4 <- 1:10
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 14: Numbers](https://r4ds.hadley.nz/numbers.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to parse numbers, utilize numeric transformations on variables within datasets, and learn new ways to numerically summarize data. 

## Making Numbers
### 

Our ultimate goal in this section is to make use of the functions `parse_double()` and `parse_number()` to get specific values of a variable from a certain dataset.

### Exercise 1

This chapter mostly uses functions from base R, which are available without loading any packages. But we still need the tidyverse because we’ll use these base R functions inside of tidyverse functions like mutate() and filter(). 

### 

Use `library()` let's load in the **tidyverse** package.

```{r making-numbers-1, exercise = TRUE}

```

```{r making-numbers-1-hint-1, eval = FALSE}
library(...)
```

### 

The [**readr**](https://readr.tidyverse.org/) package is one of the eight core packages in the *Tidyverse*. It provides two useful functions for parsing strings into numbers: `parse_double()` and `parse_number()`.


### Exercise 2

Define a vector `x` that has the following values within it `"1.2"`, `"5.6"`, `"1e3"`. These values are strings for now.

```{r making-numbers-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r making-numbers-2-hint-1, eval = FALSE}
x <- c(..., ..., ...)
```

### 

In most cases, you’ll get numbers already recorded in one of R’s numeric types: integer or double. In some cases, however, you’ll encounter them as strings.

### Exercise 3

When you have numbers that have been written as strings we should use `parse_double()`. So let's use use `parse_double()` on the command we just created. 

```{r making-numbers-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r making-numbers-3-hint-1, eval = FALSE}
x <- c("...", "...", "...")
parse_double(x)
```

### 

This should return an output of: `#> [1]    1.2    5.6 1000.0`.

### Exercise 4

Use `parse_number()` when the string contains non-numeric text that you want to ignore. This is particularly useful for currency data and percentages. Let's first make a vector y that has the string values: `"$1,234"`, `"USD 3,513"`, `59%`

```{r making-numbers-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r making-numbers-4-hint-1, eval = FALSE}
y <- c(..., ..., ...)
```

### 

As you can see, in this vector `y` there are non-numeric text that we would normally want to ignore if we were to see this in a dataset. 

### Exercise 5

Let's use `parse_number()` to ignore this non-numeric text.

```{r making-numbers-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r making-numbers-5-hint-1, eval = FALSE}
y <- c(..., ..., ...)
parse_number(y)
```

### 

The result you should've received is `#> [1] 1234 3513   59`

## Counts
### 

In this section, we will be reviewing how to use `count()` and other similar functions to make data analysis easier. 

### Exercise 1

Run `help(package = "dplyr")` at the Console. Find the help page for `count()`. Click on it. Copy/paste the Description below. (Don't worry about formatting.)

```{r counts-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

<!-- DK: Drop knowledge. Maybe mention add_count() or tally()? -->

### Exercise 2

Now let's load in the dataset, `flights` that we will be making use of. This dataset contains information about all flights that departed from NYC (e.g. EWR, JFK and LGA) to destinations in the United States, Puerto Rico, and the American Virgin Islands) in 2013: 336,776 flights in total. To help understand what causes delays, it also includes a number of other useful datasets.

### 

Let's load up `flights` and display the dataset.

```{r counts-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-2-hint-1, eval = FALSE}
flights
```

### 

### Exercise 3

It’s surprising how much data science you can do with just counts and a little basic arithmetic, so dplyr strives to make counting as easy as possible with count(). This function is great for quick exploration and checks during analysis

### 

Let's count the number of planes of which departed from a certain destination. Make a pipeline from `flights` and use the function `count()` on `dest`.

```{r counts-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-3-hint-1, eval = FALSE}
flights |> count(dest)
```

### 

We usually put `count()` on a single line because it’s usually used at the console for a quick check that a calculation is working as expected.

### Exercise 4

If you want to see the most common values, add the parameter sort = TRUE:

```{r counts-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-4-hint-1, eval = FALSE}
flights |> count(..., sort = TRUE)
```

### 

And remember that if you want to see all the values, you can use `|> View()` or `|> print(n = Inf)`.

### Exercise 5

`n()` is a special summary function that doesn’t take any arguments and instead accesses information about the “current” group. This means that it only works inside `dplyr` verbs.

### 

Let's first make a pipeline with `flights` and group by the destination `dest`.

```{r counts-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-5-hint-1, eval = FALSE}
flights |> 
  group_by(...)
```

### Exercise 6

Then let's use `n_distinct(x)` which counts the number of distinct (unique) values of one or more variables. For example, we could figure out which destinations are served by the most carriers. 

### 

We can use `n_distinct(x)` by adding `summarize()` to the pipeline and making a new column named `carriers` to be the number of distinct values of the `carrier` variable.

```{r counts-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-6-hint-1, eval = FALSE}
flights |> 
  group_by(...) |> 
  summarize(carriers = n_distinct(...))
```

### Exercise 7

A weighted count is a sum. For example you could “count” the number of miles each plane flew by using the `sum()` function.

### 

But, `count()` has a `wt` argument that does the same thing. So let's make a new pipeline with flights and count that utilizes the `tailnum` and will make a weighted count with `distance`.

```{r counts-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-7-hint-1, eval = FALSE}
flights |> count(tailnum, wt = distance)
```

### Exercise 8

Now, let's count the number of cancelled flights or missing values of each destination `dest`. 

### 

Make a new pipeline with `flights` and group by the destinations. 

```{r counts-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-8-hint-1, eval = FALSE}
flights |> 
  group_by(dest)
```

### Exercise 9

Next, let's count the canceled flights in each destination by using the `summarize()` function making a new column called `n_cancelled()` and getting the sum of the number of missing values by doing the following: `sum(is.na(dep_time))`

```{r counts-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r counts-9-hint-1, eval = FALSE}
flights |> 
  group_by(dest) |> 
  summarize(n_cancelled = sum(is.na(dep_time)))
```

## Numeric Transformations
### 

This section will go over transforming numeric vectors with the function `mutate()` and using various mathematic methods to make new columns in a certain dataset.

### 

But we need to briefly talk about the *recycling rules* which determine what happens when the left and right hand sides have different lengths.

### 

For example operations like `flights |> mutate(air_time = air_time / 60)` have different lengths in the left and the right hand side. There are 336,776 individual numbers on the left of the `/` but only one number on the right. This would normally be a problem but R handles these mismatched lengths by *recycling*, or repeating, the short vector.

### 

### Exercise 1

Load in the tidyverse and dplyr packages. 
```{r numeric-transformati-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-1-hint-1, eval = FALSE}
library(tidyverse)
library(dplyr)
```

### 

### Exercise 2

We can see this in operation more easily if we create some vectors outside of a data frame. Make a new vector `x` so that the vector has the values `1, 2, 10, 20` in it. 
```{r numeric-transformati-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-2-hint-1, eval = FALSE}
x <- c(...)
```

### 

### Exercise 3

Divide the vector `x` by 5.

```{r numeric-transformati-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-3-hint-1, eval = FALSE}
x <- c(...)
x / 5
```

### 

This operation is shorthand for `x / c(5, 5, 5, 5)`. Generally, you only want to recycle single numbers (i.e. vectors of length 1), but R will recycle any shorter length vector. It usually (but not always) gives you a warning if the longer vector isn’t a multiple of the shorter.

### Exercise 4

You can see the warning message displayes when you try using a longer vector that isn't a multiple of the shorter vector. Try using the same vector but multiplying `x` with the values `1, 2, 3`.
```{r numeric-transformati-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-4-hint-1, eval = FALSE}
x <- c(1, 2, 10, 20)
x * c(...)
```

### 

### Exercise 5

These recycling rules are also applied to logical comparisons (==, <, <=, >, >=, !=) and can lead to a surprising result if you accidentally use == instead of %in% and the data frame has an unfortunate number of rows.

### 

Let's try to find all the flights in January and February. Make a new pipeline with `flights` and use the `filter()` function on `month` being 1 or 2 (January or February). However, instead of using `%in%` use `==`.

```{r numeric-transformati-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-5-hint-1, eval = FALSE}
flights |> 
  filter(month == c(...))
```

### 

The code runs without error, but it doesn’t return what you want. Because of the recycling rules it finds flights in odd numbered rows that departed in January and flights in even numbered rows that departed in February. And unfortunately there’s no warning because `flights` has an even number of rows.

### 

To protect you from this type of silent failure, most tidyverse functions use a stricter form of recycling that only recycles single values. Unfortunately that doesn’t help here, or in many other cases, because the key computation is performed by the base R function ==, not filter().

### 

### Exercise 6

Most arithmetic functions work with pairs of variables. Two closely related functions are `pmin()` and `pmax()`, which when given two or more variables will return the smallest or largest value in each row. 

### 

Let's utilize a premade dataframe `df`. Display this dataframe.
```{r numeric-transformati-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-6-hint-1, eval = FALSE}
df
```

### 

### Exercise 7

Now, make a new pipeline with df. Then, make two new columns named min and max using the `mutate()` function representing the row min and row max of the columns x and y. For example, the code for the `min` column should look like `pmin(x, y, na.rm = TRUE)`. 

```{r numeric-transformati-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-7-hint-1, eval = FALSE}
df |> 
  mutate(
    min = pmin(x, y, na.rm = TRUE),
    max = pmax(x, y, na.rm = TRUE)
  )
```

### 

Note that these are different to the summary functions min() and max() which take multiple observations and return a single value.

### 

### Exercise 8

Modular arithmetic is the technical name for the type of math you did before you learned about decimal places, i.e. division that yields a whole number and a remainder. In R, `%/%` does integer division and `%%` computes the remainder.

### 

Make a new vector `z` equal to the numbers ranging from 1 to 10. 

```{r numeric-transformati-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-8-hint-1, eval = FALSE}
z <- c(1:10)
```

### 

### Exercise 9

Using the same vector, `z`, divide by 3 using integer division (`%/%`) and also compute the remainder using `%%`.
```{r numeric-transformati-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-9-hint-1, eval = FALSE}
z <- c(1:10)
z %/% 3
z %% 3
```

### 

### Exercise 10

Modular arithmetic is handy for the `flights` dataset, because we can use it to unpack the `sched_dep_time` variable into `hour` and `minute`. `sched_dep_time` has the time in a numerical form where the thousands and hundreds place is the hour and the ones' and tens' place is the minute.

### 

Make a new pipeline with flights and use `mutate()` to make 2 new columns named `hour` and `minute` using integer division to find the hour and remainder computation to find the minute. Add the parameter `.keep = "used"` to retain only the columns used in `sched_dep_time` to create new columns
```{r numeric-transformati-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-10-hint-1, eval = FALSE}
flights |> 
  mutate(
    hour = sched_dep_time %/% 100,
    minute = ...,
    .keep = "used"
  )
```

### 

### Exercise 11

Now let's make a plot to see how the proportion of cancelled flights varies over the course of the day.

### 

Copy the previous code and make a new column named `prop_cancelled` using `summarize()` that is equivalent to `mean(is.na(dep_time)), n = n())`
```{r numeric-transformati-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-11-hint-1, eval = FALSE}
flights |> 
  mutate(
    hour = sched_dep_time %/% 100,
    minute = ...,
    .keep = "used"
  ) |> 
  summarize(prop_cancelled = mean(is.na(dep_time)), n = n())
```

### 

### Exercise 12

Continue by filtering the hours that are greater than 1 AM.
```{r numeric-transformati-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-12-hint-1, eval = FALSE}
... |> 
  filter(hour > 1)
```

### 

### Exercise 13

Add to the pipeline by adding `ggplot()` and mapping the x-axis to `hour` and the y-axis to `prop_cancelled`
```{r numeric-transformati-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-13-hint-1, eval = FALSE}
... |> 
  ggplot(aes(x = hour, y = prop_cancelled))
```

### 

### Exercise 14

Add to the pipeline by using `geom_line()` to make a line plot and add a `color` argument with the value of `"grey50"` to make a gray line. 
```{r numeric-transformati-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-14-hint-1, eval = FALSE}
... +
  geom_line(color = "grey50")
```

### 

### Exercise 15

Add to the pipeline and use `geom_point()` mapping `size` to `n` using `aes()`. 
```{r numeric-transformati-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-15-hint-1, eval = FALSE}
... + 
  geom_point(aes(size = n))
```

### 

### Exercise 16

```{r numeric-transformati-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-16-hint-1, eval = FALSE}

```

### 

### Exercise 17

Add appropriate labels for the title, x-axis, and the y-axis using labs().
```{r numeric-transformati-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r numeric-transformati-17-hint-1, eval = FALSE}
... +
  labs(title = ..., 
       subtitle = ..., 
       x = ..., 
       y = ...)
```

### 

This is a line plot with scheduled departure hour on the x-axis, and proportion of cancelled flights on the y-axis. An observation that we could make is that cancellations seem to accumulate over the course of the day until 8pm, very late flights are much less likely to be cancelled.

### 

## Other Number Functions
### 

This section will allow you to practice with many other number functions with many different uses.

### Exercise 1

Run `?log()` in the Console and copy paste the Description below. (Don't worry about formatting)
```{r other-number-functio-1}
question_text(NULL,
	message = "Place correct answer here.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Logarithms are an incredibly useful transformation for dealing with data that ranges across multiple orders of magnitude and converting exponential growth to linear growth.

### 

### Exercise 2

Use the function `round()` with the argument `123.456` and hit "Run Code".
```{r other-number-functio-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-2-hint-1, eval = FALSE}
round(...)
```

### 

The function round(x) rounds a number to the nearest integer. You can control the precision of the rounding with the second argument, digits. round(x, digits) rounds to the nearest 10^-n so digits = 2 will round to the nearest 0.01.

### 

### Exercise 3

Copy your previous code and add the `digits` argument to the `round()` function and make `digits = 2`.
```{r other-number-functio-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-3-hint-1, eval = FALSE}
round(..., digits = 2)
```

### 

You can control the precision of the rounding with the second argument, digits. round(x, digits) rounds to the nearest 10^-n so digits = 2 will round to the nearest 0.01.

### 

### Exercise 4

Copy your previous code and change the `digits` argument to `-2`. 
```{r other-number-functio-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-4-hint-1, eval = FALSE}
round(..., digits = ...)
```

### 

The *-2* argument in the `round()` function will round the number `123.456` to the nearest hundred which would be 100 in this case.

### 

### Exercise 5

Type in `round(c(1.5, 2.5))` and hit "Run Code".

```{r other-number-functio-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-5-hint-1, eval = FALSE}
round(...)
```

### 

round() uses what’s known as “round half to even” or Banker’s rounding: if a number is half way between two integers, it will be rounded to the even integer. This is a good strategy because it keeps the rounding unbiased: half of all 0.5s are rounded up, and half are rounded down.

### 

### Exercise 6

The functions `floor()` and `ceiling()` are paired with `round()`. Use the function `floor()` with the numerical argument of `123.456`. 
```{r other-number-functio-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-6-hint-1, eval = FALSE}
floor(...)
```

### 

The function `floor()` will always round down to the nearest integer.
### Exercise 7

Type in ceiling() with the numerical argument of `123.456`. 
```{r other-number-functio-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-7-hint-1, eval = FALSE}
ceiling(...)
```

### 

The function `ceiling()` always round up to the nearest integer.

### 

### Exercise 8

Make a new variable `x` and set it to the number 123.456.
```{r other-number-functio-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-8-hint-1, eval = FALSE}
x <- ...
```

### 

The `floor()` and `ceiling()` functions don’t have a digits argument, so you can instead scale down, round, and then scale back up

### 

### Exercise 9

Let's round down to the nearest two digits. Type in `floor(x / 0.01) * 0.01` and hit "Run Code".
```{r other-number-functio-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-9-hint-1, eval = FALSE}
floor(...) * ...
```

### 

### Exercise 10

Let's round up to the nearest two digits. Type in `ceiling(x / 0.01) * 0.01` and hit "Run Code". 
```{r other-number-functio-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-10-hint-1, eval = FALSE}

```

### 

You can use the same technique if you want to round() to a multiple of some other number

### 

### Exercise 11

Let's round to the nearest multiple of 4. Type in `round(x / 4) * 4` and hit "Run Code".
```{r other-number-functio-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-11-hint-1, eval = FALSE}
round(...) * ...
```

### 

### Exercise 12

This time let's round to the nearest 0.25. Type in `round(x / 0.25) * 0.25` and hit "Run Code".
```{r other-number-functio-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-12-hint-1, eval = FALSE}
round(...) * ...
```

### 

### Exercise 13

Make a new vector `x3` and set it to equal `c(1, 2, 5, 10, 15, 20)`. 
```{r other-number-functio-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-13-hint-1, eval = FALSE}
x3 <- c(...)
```

### 

Use `cut()`(https://rdrr.io/r/base/cut.html) to break up (aka bin) a numeric vector into discrete buckets.

### 

### Exercise 14

Use `cut()` on the numeric vector `x` and add in the `breaks` argument and set `breaks` to `c(0, 5, 10, 15, 20)`
```{r other-number-functio-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-14-hint-1, eval = FALSE}
cut(x3, breaks = ...)
```

### 

### Exercise 15

The breaks don't need to be evenly spaced. Copy the previous code and change the `breaks` argument and set it to `c(0, 5, 10, 100)`.
```{r other-number-functio-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-15-hint-1, eval = FALSE}
cut(x3, breaks = ...)
```

### 

You can optionally supply your own `labels`. Note that there should be one less `labels` than `breaks`. 

### 

### Exercise 16

Copy your previous code and add a new argument called `labels` and set it to `c("sm", "md", "lg")`.
```{r other-number-functio-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-16-hint-1, eval = FALSE}
cut(x3, 
    breaks = ...,
    labels = c(...))
```

### 

Any values outside of the range of the breaks will become `NA`. See the documentation for other useful arguments like `right` and `include.lowest`, which control if the intervals are [a, b) or (a, b] and if the lowest interval should be [a, b] by running `?cut()` in the Console.

### 

### Exercise 17

Make a new vector `x4` and set it to `1:10`.

```{r other-number-functio-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-17-hint-1, eval = FALSE}
x4 <- ...
```

### 

Base R provides cumsum(), cumprod(), cummin(), cummax() for running, or cumulative, sums, products, mins and maxes. dplyr provides cummean() for cumulative means. Cumulative sums tend to come up the most in practice. 

### 

### Exercise 18

Use the function `cumsum()` on `x4`.
```{r other-number-functio-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r other-number-functio-18-hint-1, eval = FALSE}
cumsum(...)
```

### 

The function `cumsum()` will cumulate the sum using all the previous integers within the vector

### 

## General Transformations
### 

This section will allow you to make use of transformations on an actual dataframe.



## Numeric Summaries
### 

This section will introduce more useful summary functions that will help to summarize your data much better.

## Summary
### 

This tutorial covered [Chapter 14: Numbers](https://r4ds.hadley.nz/numbers.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
